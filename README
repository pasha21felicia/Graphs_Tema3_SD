Digori Parascovia - Tema 3 - SD - Grafuri

Problema 2 - Reprezentanti
Pentru aceasta problema am creatul graful Graph in care retin n-nr de noduri, m-nr de muchii, x-nr de reprezentanti si adj-matricea de adiacenta.
Cu functia readAdjMatrix citesc perechile src, dest, weight si creez matricea de adiacenta, care este o matrice simetrica. In vectorul repr pastrez reprezentantii. Pentru calcului drumului de cost minim folosesc algoritmul dijkstra pe matricea de adiacenta - functia shortest_path(). Deasemenea pentru a micsora timpul de executie am ales sa gasesc cel mai scurt drum de la fiecare reprezentant catre fiecare nod. In functia shortest_path mai intaii initializam vectorul dist[] cu infinit si included[] cu 0. Parcurgem toate nodurile si cu ajutorul functiei min_distance obtinem nodul cu drum minim din cadrul nodurilor neprocesate inca. Nodul respectiv se marcheaza ca inclus (included[node] = 1). Cu un for se parcurg nodurile si se updateaza distanta nodului ales pentru nodurile vecine. Astfel elementul dist[i] ajunge sa contina distanta minima de la reprezentatul respectiv la fiecare nod i. Aplic functia compare() asupra vectorului dist pentru a afla distanta minima catre nodul i de la fiecare reprezentant, aceasta pastrandu-se in vectorul aux iar vectorul poz va contine insasi reprezentantul cu drum minim. La final printez poz[i] si dist[i] adica reprezentantul si distanta minima a nodului i.

Probleme 4 - Labirint

In aceasta problema am folosit direct forma matriceala a grafului, lucrand direct pe matricea data. Cu functia read_matrix citesc matricea din fisier si salvez coordonatele initiale ale lui David (elementul 2) si vectorul de directii directions[]. Pentru alfarea pozitiilor finale ale lui David am decis sa ii trasez drumul liber cu un nr diferit de 0, 1, 2 iar la fiecare schimbare de directie sa incrementez acest nr. Traseul in directia corespunzatoare se face prin cele 4 functii up, down, left right care parcurg directia si pozitioneaza nr pe celula atat timp cat drumul este deschis, adica = cu 0. In functia paths creez traseele, mai intaii parcurg prima directie in care pozitionez nr=3 si il incrementez spre 4 pentru a schimba directia. Pentru toate celelate directii parcurg matricea si daca gasesc nr-1 in ea (ex. daca ar fi a doua directie gasesc 3) atunci incepand pozitia gasita fac traseul in directia noua(cat drumul este egal cu 0). Repetand aceasta procedura pentru fiecare directie in parte, ajung sa suprascriu pozitii, astfel incat valoare ultimului nr (prin incrementare) se afla pe ultima pozitie a lui David din fiecare drum posibil.
Astfel, la final cu functia nr_final_positions() numar cate celule in matrice au valoare nr-1, adica cate pozitii finale sunt.
